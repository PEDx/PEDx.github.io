<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 对querySelectorAll 的一些区分 · Pedclub</title><meta name="description" content="对querySelectorAll 的一些区分 - ped"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.pedclub.com/atom.xml" title="Pedclub"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2020592511/home?topnav=1&amp;wvr=5" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/PEDx" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">对querySelectorAll 的一些区分</h1><div class="post-info">Feb 14, 2016</div><div class="post-content"><p>在一年多以前我在入门前端的时候学到 <code>querySelectorAll</code> 这个<code>API</code>时有一个疑问, 如此强大的 js 选择器方法并且老早就标准化的<code>API</code>(在浏览器端支持到 IE8+), 为什么在网上很难看到其他人在使用, 经过对 <code>JavaScript DOM</code>特性的深入了解和查阅一些资料, 才发现自己对 DOM 的一些概念没有加以深刻的区分, 今天在此基础上对这个方法做一个总结.</p>
<h2 id="类型上的区分"><a href="#类型上的区分" class="headerlink" title="类型上的区分"></a>类型上的区分</h2><p>说到 <code>querySelector()</code>和 <code>querySelectorAll()</code> 这两个方法, 首先要明确的是它是 W3C 组织对 <code>DOM API</code> 的专有扩展, 名叫 <code>Selectors API Level 1</code>, 与 <code>getElementsBy*</code> 系列分属不同的 API 集合, 扩展方法得以成为标准得益于 JS 社区面对频繁繁琐的 DOM 操作实现的各种选择器轮子, 最出名的当属从 <code>jQuery</code> 中独立出的 <code>Sizzle</code>.</p>
<p>随着移动端在互联网终端份额中独占鳌头, 移动前端开发者迫切需要一个轻量级不需要考虑 PC Web 端那么多历史遗留问题的类<code>jQuery</code>库, <code>Zepto</code>应运而生, 就其内部选择器的实现上比 jQuery 的选择器模块小很多, 这是其轻量的重要原因之一, 下面的代码就是 <code>Zepto 0.8</code> 版本的选择器模块.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// $$ 核心选择器函数</span></div><div class="line">$.qsa = $$ = <span class="function"><span class="keyword">function</span>(<span class="params">element, selector</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> found;</div><div class="line">    <span class="comment">// 匹配id选择器</span></div><div class="line">    <span class="keyword">return</span> (element === <span class="built_in">document</span> &amp;&amp; idSelectorRE.test(selector)) ?</div><div class="line">        ((found = element.getElementById(<span class="built_in">RegExp</span>.$<span class="number">1</span>)) ? [found] : emptyArray) :</div><div class="line">        slice.call(</div><div class="line">            <span class="comment">// 匹配 .className 类选择器</span></div><div class="line">            classSelectorRE.test(selector) ? element.getElementsByClassName(<span class="built_in">RegExp</span>.$<span class="number">1</span>) :</div><div class="line">            <span class="comment">// 匹配 div 标签选择器</span></div><div class="line">            tagSelectorRE.test(selector) ? element.getElementsByTagName(selector) :</div><div class="line">            <span class="comment">// 都不匹配就 传入到 querySelectorAll() 方法来选择 dom 元素</span></div><div class="line">            element.querySelectorAll(selector)</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Zepto</code> 在 <code>0.8</code> 版本之后选择器架构上做了一些升级, 但大概的设计原则没有变, 就是能用 <code>getElementsBy*</code> 系列的就尽量不使用 <code>querySelectorAll</code><br><a id="more"></a></p>
<h2 id="取得元素的类型区分"><a href="#取得元素的类型区分" class="headerlink" title="取得元素的类型区分"></a>取得元素的类型区分</h2><p>这两种 API 在取得的元素上有什么区分呢, 看代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            middle</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>)</div><div class="line"><span class="built_in">console</span>.log(divs.length)    <span class="comment">// 5</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>))</div><div class="line"><span class="built_in">console</span>.log(divs.length)    <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> divs2 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)</div><div class="line"><span class="built_in">console</span>.log(divs2.length)   <span class="comment">// 6</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>))</div><div class="line"><span class="built_in">console</span>.log(divs2.length)   <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p>我们发现 <code>querySelectorAll</code> 取得的元素集合好像不会动态增加, 而 <code>getElementsByTagName</code> 取得的却可以, 原因是这两种方法取得的元素集合在类型上的不同, 因而在其表现上就不同. <code>querySelectorAll</code> 取得的是一种叫做 <code>static NodeList</code> 的’静态’集合, 更像是文档片断的快照, 而<code>getElementsByTagName</code>取得的是叫做 <code>HTMLCollection</code> 的一种’动态’集合’, 文档实时的添加元素会反映到当前集合中. 这种区分是在 W3C 规范中加以明确区分的, 在日常开发中, 两者的分别导致的影响并不大, 尤其是在使用类库的一些<code>dom</code>操作 API 时, 类库帮我们除去了一些意料之外的坑.</p>
<div class="tip"><br>注意: 这两种集合都是一个类数组对象, 上面的区分只反应在集合这个尺度上, 在集合中的每个具体元素有它们各自的类型, 如果我们修改集合中具体元素的特性, 是会同步到元素本身上的, 这一点要加以区分<br></div>


<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>这两者除了在本身类型和取得元素类型上的区分, 另外一个有更大实际影响的区分, 就是两者在选择元素性能上的区别. 可以说在选择性能上<code>getElementsByTagName()</code> 比 <code>querySelectorAll()</code> 快100倍, 这种性能级别的差距让人出乎意料, 也不难解释 <code>Zepto</code> 的核心选择器模块不都使用 <code>querySelectorAll</code> 来实现元素的选择.</p>
<p>究竟是什么原因导致这种性能差距呢, 这不得不从两者选择元素的方式上说起.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"warning"</span>&gt;</span>This is a sample warning<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>This is a sample error<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bar"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 querySelectorAll</span></div><div class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>)</div><div class="line"><span class="built_in">console</span>.log(foo.querySelectorAll(<span class="string">"div &gt; p"</span>).length) <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 jquery</span></div><div class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>)</div><div class="line"><span class="built_in">console</span>.log(($(foo).find(“div &gt; p”).length) <span class="comment">//0</span></div></pre></td></tr></table></figure>
<p>值得注意的是我们在取到 <code>foo</code> 这个 <code>div</code> 元素后再利用子代选择器选择这个 <code>div</code> 中的所有 <code>p</code> 元素, 我们发现这两种方式选择到的元素集合有差别.</p>
<p>在 jquery 中使用 find 方法是基于当前调用元素作为 <code>context</code> 上下文来对元素进行选择, 因为 <code>foo</code> 这个 <code>div</code> 作为上下文, 其中并没有一个 <code>div</code> 用来匹配 jquery 中的子代选择器, 所以选择不到 <code>p</code>元素</p>
<p>而 <code>querySelectorAll</code> 在选择上下文上是按照 W3C 的规范实现的, 并不会管其当前调用元素, 它的选择方式是先在整个文档中来进行上下文查找的, 在整个文档中匹配完后, 再去根据当前调用元素进行限定过滤, 因此我们先在文档中选择得到了元素 <code>p</code> 集合, 然后再与<code>foo</code> 这个 <code>div</code>的内部进行对比, 符合就返回, 不符合就过滤掉.</p>
<p>选择方式的差别是性能的差别的其中一个因素, 在更进一步的内部实现原理上我们才可以一窥其性能差别的主要原因.</p>
<p>在浏览器内部, 我们每当要取一个静态的<code>NodeList</code>实例, 都先会去创建一个新的对象 ,然后读取所有当前<code>dom</code>对象的数据填充到这个新的对象中去, 而在获取动态的<code>NodeList</code>实例或<code>HTMLCollection</code>等’动态’集合时, 浏览器直接从文档缓存中获取当前<code>dom</code>对象进行一一映射返回, 不需要任何前期的构造, 对比静态的<code>NodeList</code>实例的创建少了大量额外的前期工作.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/13/photoshop-e9-a2-9c-e8-89-b2-e6-a8-a1-e5-bc-8f-e5-85-a5-e9-97-a8/" class="prev">PREV</a><a href="/2016/01/14/hello-world/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://www.pedclub.com">ped</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>