<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript函数的去抖与节流 · Pedclub</title><meta name="description" content="JavaScript函数的去抖与节流 - ped"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.pedclub.com/atom.xml" title="Pedclub"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2020592511/home?topnav=1&amp;wvr=5" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/PEDx" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript函数的去抖与节流</h1><div class="post-info">Dec 14, 2015</div><div class="post-content"><p>在日常前端开发中经常会遇到这样一种场景, 为一个 <code>DOM</code> 元素绑定一个 <code>mousemove</code>事件来监听鼠标移动事件后, 当我们移动鼠标触发事件时, 会发现事件处理函数被触发了无数次, 在具体项目中, 这种不加限制的触发事件处理函数, 且处理函数中有<code>DOM</code>的重绘操作, 将会导致浏览器的界面卡顿, 尤其是除了<code>chrome</code>浏览器以外的其他浏览器, 卡顿是非常明显的.</p>
<p>在一次实现3D视角的<code>banner</code> 过程中, 需要使用<code>mousemove</code>来监听鼠标移动事件, 相应的处理函数对<code>banner</code>元素利用 <code>CSS3</code>的<code>transform</code>做出相应的3D动画变换, 并在 CSS 中为元素添加了<code>transition</code>动画过渡属性, 开发完成后在<code>chrome</code>浏览器中效果出类拔群, 但换到 <code>firefox</code> 和 <code>ie</code> 中去测试时却傻了眼, 动画帧率很低, 对鼠标的响应十分卡顿, <code>google</code> 后的解决方案是在3d变换中加入<code>translateZ: 0</code>, 即 利用空转的 Z 轴变换来欺骗浏览器开启图形加速, 万分期待的加入这个属性后然而并没有什么*用, 返回去研究<code>mousemove</code>事件特性后, 才在 <code>google</code>中找到了只言片语, 即使用函数节流来对持续触发事件加以限制以节省性能.</p>
<h2 id="节流与去抖"><a href="#节流与去抖" class="headerlink" title="节流与去抖"></a>节流与去抖</h2><p>在经典的 <code>&lt;&lt; JavaScript 高级程序设计 &gt;&gt;</code>中就有对函数节流的简单实现, 遗憾的是这并不是<code>throttle</code>–函数节流, 而是<code>debounce</code>–函数去抖的简单实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>) </span>&#123;</div><div class="line">    clearTimeout(method.tId);</div><div class="line">    method.tId= setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        method.call(context);</div><div class="line">    &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码利用的是<code>setTimeout``clearTimeout</code>这两个方法来保证在<code>100ms</code>时间内只要触发了事件方法都会重新延时, 直到某次停顿超过<code>100ms</code>后函数才会执行, 这是函数去抖的经典实现却不是函数节流.</p>
<p>在 <code>underscore</code>中有对这两个方法的实现, 以下是对函数节流的正确实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> context,</div><div class="line">        args,</div><div class="line">        result;</div><div class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!options)</div><div class="line">        options = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        previous = options.leading === <span class="literal">false</span></div><div class="line">            ? <span class="number">0</span></div><div class="line">            : _.now();</div><div class="line">        timeout = <span class="literal">null</span>;</div><div class="line">        result = func.apply(context, args);</div><div class="line">        <span class="keyword">if</span> (!timeout)</div><div class="line">            context = args = <span class="literal">null</span>;</div><div class="line">        &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> now = _.now();</div><div class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>)</div><div class="line">            previous = now;</div><div class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</div><div class="line">        context = <span class="keyword">this</span>;</div><div class="line">        args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</div><div class="line">            <span class="keyword">if</span> (timeout) &#123;</div><div class="line">                clearTimeout(timeout);</div><div class="line">                timeout = <span class="literal">null</span>;</div><div class="line">            &#125;</div><div class="line">            previous = now;</div><div class="line">            result = func.apply(context, args);</div><div class="line">            <span class="keyword">if</span> (!timeout)</div><div class="line">                context = args = <span class="literal">null</span>;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</div><div class="line">            timeout = setTimeout(later, remaining);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>函数节流所要解决的是在规定时间内, 无论触发多少次事件, 最后在这个时间段内只会执行一次事件处理函数, 就像筛子一样将高密度不可预估的事件触发变为可对事件触发的间隔时间段加以控制, 因此得以对整体性能的节省.</p>
<p>对于文章开头所实现的业务功能, 使用<code>throttle</code>函数节流后就完美抹平了在不同浏览器之间的性能差异问题.</p>
<p>而函数去抖的经典适用场景是在<code>jQuery</code>中的<code>show</code>方法中, 已知我们有以下业务场景, 当鼠标<code>hover</code>一个<code>DOM</code>元素后,当前<code>DOM</code>元素会弹出一个小卡片浮层且有动画效果, 在对兼容性有要求后不能使用<code>CSS3</code>来实现的场景下, 就可以用到<code>jQuery</code>中的<code>show</code>方法.</p>
<p> 但<code>show</code>方法是默认有动画队列的存在, 即当我们短时间<code>hover</code>很多次当前<code>DOM</code>元素后, 会看到浮层的动画会不紧不慢的执行了很多次, 用户体验很差, 这样的场景就可以用到<code>debounce</code>函数去抖来消除动画队列带来的延迟执行多次的问题. 也可以在<code>show</code>方法中传入<code>queue: false</code>字段来消除动画队列带来的问题.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/14/关于querySelectorAll 的一些区分/" class="prev">上一篇</a><a href="/2015/04/14/array&amp;string/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://www.pedclub.com">ped</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>