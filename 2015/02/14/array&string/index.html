<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数组及字符串方法速查 · Pedclub</title><meta name="description" content="数组及字符串方法速查 - ped"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.pedclub.com/atom.xml" title="Pedclub"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2020592511/home?topnav=1&amp;wvr=5" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/PEDx" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">数组及字符串方法速查</h1><div class="post-info">Feb 14, 2015</div><div class="post-content"><h1 id="数组及字符串方法速查"><a href="#数组及字符串方法速查" class="headerlink" title="数组及字符串方法速查"></a>数组及字符串方法速查</h1><p>###一.数组方法</p>
<ol>
<li><p>数组检测</p>
<blockquote>
<p>[].isArray(value)</p>
</blockquote>
<p>（ie9+）用于确定一个值是否是一个数组，无论数值在什么环境下创建，返回布尔值。</p>
</li>
<li><p>数组的转换方法</p>
<blockquote>
<p>[].toString() </p>
</blockquote>
<p>继承自对象<br>这个返回一个由逗号拼接数组各个元素的字符串，原数组不变。</p>
<blockquote>
<p>[].valueOf()</p>
</blockquote>
<p>继承自对象<br>返回原数组，原数组不变。</p>
<blockquote>
<p>[].toLocaleString() </p>
</blockquote>
<p>继承自对象<br>返回和toString()方法相同的值，原数组不变。</p>
<blockquote>
<p>[].join()</p>
</blockquote>
<p>传入分割符，以这个符号来拼接数组个元素成为一个字符串,原数组不变。</p>
</li>
<li><p>栈方法</p>
<blockquote>
<p>[].push(value)</p>
</blockquote>
<p>接受任意值，将他们添加到数组最后一项，并改变数组的length属性，返回改变后的length值。</p>
<blockquote>
<p>[].pop() </p>
</blockquote>
<p>将数组最后一项移除，改变length属性，返回被移除元素。</p>
</li>
<li><p>队列方法</p>
<blockquote>
<p>[].shift()</p>
</blockquote>
<p>将数组的第一项移除，改变length属性，返回被移除元素。</p>
<blockquote>
<p>[].unshift(value)</p>
</blockquote>
<p>接受任意值，将他们添加到数组的第一项，改变length属性，返回改变后的length值。</p>
</li>
<li><p>重排序方法</p>
<blockquote>
<p>[].reverse()</p>
</blockquote>
<p>数组的重排序方法，反转数组的数组项顺序，改变并返回原数组。</p>
<blockquote>
<p>[].sort()</p>
</blockquote>
<p>sort方法默认会先调用每一个数组项的toString()方法，然后比较得到的字符串，大多数情况下并不适用，因此，这个方法可以传入一个比较函数作为参数。</p>
<p>比较函数接受两个参数值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[].sort(compare*)；</div><div class="line"></div><div class="line">升序</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare1</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">降序</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare2</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &lt; value2)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">优化版本</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare3</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value2 - value1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>操作方法</p>
<blockquote>
<p>[].concat()</p>
</blockquote>
<p>基于当前调用数组产生一个新的数组，当不传值时返回一个当前数组的拷贝（浅拷贝）。当传入一个数组时，将会数组的每一项逐次添加进入调用数组的当前拷贝数组中。当传入的是一个值时，会将这个值简单的添加到当前拷贝数组的末尾。最后返回这个拷贝数组，不影响原数组。</p>
<blockquote>
<p>[].slice([begin[, end]])</p>
</blockquote>
<p>基于当前调用数组的一项或者多项创建出一个新数组。接受一个或两个参数,当传入一个参数时，返回一个当前从参数值begin指定的位置开始到当前调用数组末尾的所有项。当传入两个参数时返回开始begin到结束end之间的所有项，不包括end项。方法最后返回这些项组成的一个数组，不影响原数组。</p>
<blockquote>
<p>[].splice()</p>
</blockquote>
<p>主要向数组中插入项，返回改变后的原数组。</p>
<p>删除：传入两个参数，第一个是开始的下标，第二个是要连续删除多少项。</p>
<p>插入：传入三个参数，第一个是开始的下标，第二个是要删除多少项（ =0 ），第三个是要插入的项（可以是多项）。</p>
<p>替换：传入三个参数，第一个是下标的开始，第二个是要删除多少项（ &gt;0 ),第三个时要插入的项（可以使多项）。</p>
</li>
<li><p>位置方法</p>
<blockquote>
<p>[].indexOf()</p>
</blockquote>
<p>从前到后查找，接受两个参数，第一个是要查找的项，第二个是可选的查找起点位置的索引。返回查找项的索引值，没有找到返回-1</p>
<blockquote>
<p>[].lastIndex()</p>
</blockquote>
<p>从后向前查找，接受两个参数，第一个是查找项，第二个是可选的查找起点位置的索引。返回查找项的索引值，没有找到返回-1.</p>
</li>
<li><p>数组的迭代方法 ( IE9+ )<br>这些方法都接受两个参数，一个是要在每一项运行的处理函数，和可选的该处理函数的作用域对象（this）。都不改变原数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>[].every()</p>
</blockquote>
<p> 对数组每一项运行给定handle函数，如果该函数处理后的每一项都返回true，那么最后就返回true。</p>
<blockquote>
<p>[].filter()</p>
</blockquote>
<p> 给定函数handle处理后返回true的数组项组成一个新数组返回。</p>
<blockquote>
<p>[].forEach()</p>
</blockquote>
<p> 只是运行给定处理函数，无返回值</p>
<blockquote>
<p>[].map()</p>
</blockquote>
<p> 给定处理函数处理后的每一个数组项的返回值组成一个新数组返回。</p>
<blockquote>
<p>[].some()</p>
</blockquote>
<p> 给定处理函数直到处理一个数组项返回一个true，就返回true，不然返回false。</p>
<ol>
<li><p>数组的归并方法( ES5 )<br>共有两个方法，都会迭代数组，然后构建一个最终返回的值。都可传入两个参数，一个是在每一项上调用的处理函数，一个是作为归并基础的初始值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>[].reduce()<br>[].reduceRight()</p>
</blockquote>
<p> handle函数返回的任何值，都会在下一次迭代以第一个参数prev自动传入<br> 唯一的区别是一个从开始到末尾，一个从末尾到开始。</p>
<p>###三.字符串的方法</p>
<ol>
<li><p>字符方法</p>
<blockquote>
<p>charAt(number)</p>
</blockquote>
<p>以单字符字符串的形式返回给定位置的那个字符，（数组下标形式访问更好）</p>
<blockquote>
<p>charCodeAt(number)</p>
</blockquote>
<p>以单字符字符串的形式返回给定位置的那个字符的字符编码</p>
</li>
<li><p>字符串操作方法</p>
<blockquote>
<p>string.cancat()</p>
</blockquote>
<p>将一个或多个字符串拼接起来，返回拼接得到的新字符串。（以 + 号连接更好）</p>
<blockquote>
<p>string.slice()<br>string.substr()<br>string.substring()</p>
</blockquote>
<ul>
<li>都返回操作字符串的一个子字符串，都传入两个参数，第一个指定子字符串的开始位置，第二个参数表示到哪里结束。</li>
<li>不同的是substr的第二个参数表示个数。</li>
<li>如果这三个方法都不传第二个参数，那么都返回以第一个参数为下标到字符串末尾位置的字符子串。</li>
</ul>
</li>
<li><p>字符串位置方法</p>
<blockquote>
<p>indexOf()<br>lastIndexOf()</p>
</blockquote>
<p>这两个方法都从一个字符串搜索给定子字符串，返回子字符串的位置索引，如果没有找到就返回-1.两个的区别是indexOf从字符串开头向后搜索，另一个从字符串末尾向前搜索。<br>这两个方法都能接受另外的第二个参数，表示从字符串中的哪个位置开始搜索。indexOf从这个位置向后搜索，lastIndexOf从这个位置向前搜索。</p>
</li>
<li><p>sting.trim( ) (ES5)<br>返回一个当前调用字符串的一个副本，这个方法用于修剪掉字符串两头的空格</p>
</li>
<li><p>字符串大小写转换方法</p>
<blockquote>
<p>string.toLowerCase()<br>string.toLocaleLowerCase()<br>string.toUpperCase()<br>string.toLocaleUpperCase()</p>
<p>Locale字段是针对特定地区的字符大小写转换方法</p>
</blockquote>
<p>string.toLowerCase()将字符串中的字符全部转换成小写字母，返回转换后的副本。<br>string.toUpperCase()将字符串中的字符全部转换成大写字母，返回转换后的副本。</p>
</li>
<li><p>字符串模式匹配方法</p>
<blockquote>
<p>string.match()</p>
</blockquote>
<p>方法接受一个正则表达式字面量或者RegExp对象，返回一个数组, 数组模式与正则表达式的 exec 方法返回的模式相同<br>数组第一项表示匹配到的字符串, 如果正则中有捕获组, 第二项开始就是捕获到的字符串</p>
<blockquote>
<p>string.search()</p>
</blockquote>
<p>此方法接受参数与 match 方法一致, 返回字符串中第一个匹配项的索引</p>
<blockquote>
<p>string.repleace()</p>
</blockquote>
<p>第一个参数是字符串或者正则表达式, 第二个参数是字符串. 如果想要替换字符串中所有匹配的子串, 需要使用正则表达式并加上全局参数 g 来进行替换, 参数一为字符串的话只能替换第一个匹配到的字串</p>
<p>利用正则的模式匹配在参数二中使用字符序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>; </div><div class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($1)"</span>); </div><div class="line">alert(result); </div><div class="line"><span class="comment">//word (cat), word (bat), word (sat), word (fat)</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p> 参数二还可以是一个函数, repleace 会向函数传递 3 个参数, 分别是模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下, 传递给函数的参数依次是模式的匹配项、第一个捕获组的匹 配项、第二个捕获组的匹配项……, 但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>)</span>&#123; </div><div class="line">    <span class="keyword">switch</span>(match)&#123; </div><div class="line">        <span class="keyword">case</span> <span class="string">"&lt;"</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"&gt;"</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"&amp;"</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"\""</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"&amp;quot;"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>string.split()</p>
</blockquote>
<p> 此方法可以基于指定的分隔符, 分隔符不限于字符串, 也可以是正则表达式, 会将一个字符串分割成多个子字符串，并将结果放在一个数组中。</p>
<ol>
<li><p>string.localeCompare()方法</p>
</li>
<li><p>String.fromCharCode()方法 静态方法</p>
<p>接收一或多个字符编码，然后将它们转换成一个字符串。与实例方法 charCodeAt() 执行的是相反的操作。</p>
</li>
<li><p>HTML 方法</p>
</li>
</ol>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/14/关于querySelectorAll 的一些区分/" class="prev">上一篇</a><a href="/2015/01/14/hello-world/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://www.pedclub.com">ped</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>