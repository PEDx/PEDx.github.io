<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pedclub</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.pedclub.com/"/>
  <updated>2016-10-22T11:34:05.000Z</updated>
  <id>http://www.pedclub.com/</id>
  
  <author>
    <name>ped</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript对象及原型链</title>
    <link href="http://www.pedclub.com/2016/10/17/prototype/"/>
    <id>http://www.pedclub.com/2016/10/17/prototype/</id>
    <published>2016-10-17T11:37:01.000Z</published>
    <updated>2016-10-22T11:34:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 js 这门语言向前发展过程中.我们发现不管是最新确立的 ES2015 还是 TypeScript 都在 js 面向对象这一语言特性上做了一定程度的改变,转译后都把 js 原型继承用来实现了新版本语言特性中的类继承,而不是用 js 原生的面向对象特性.这在某种意义上对原型继承模式的封装,方便了其他传统类继承语言的程序员能够快速切换到 js 语言环境.而类继承更加直观和简洁,因为转译的实现,js 程序员可以在平时写 js 过程中使用这种更为好用的特性,当然这是一种可选项,类似于 js 语言的行末分号,写的话可能麻烦但是严谨,不写的话代码更加简洁,并能够处理绝大多数情景 (js 引擎自动插入分号而导致) bug.</p>
<a id="more"></a>
<h2 id="为什么我们要清楚-js-的原型继承"><a href="#为什么我们要清楚-js-的原型继承" class="headerlink" title="为什么我们要清楚 js 的原型继承"></a>为什么我们要清楚 js 的原型继承</h2><p>当然首先是我们正值2016年底的当下,我们编程面对的客户端–浏览器对 js 的最新标准实现参差不齐,尤其是因为一些历史遗留问题,在 IE 低版本的兼容上更会消耗我们的精力.我们依旧要学习 js</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 js 这门语言向前发展过程中.我们发现不管是最新确立的 ES2015 还是 TypeScript 都在 js 面向对象这一语言特性上做了一定程度的改变,转译后都把 js 原型继承用来实现了新版本语言特性中的类继承,而不是用 js 原生的面向对象特性.这在某种意义上对原型继承模式的封装,方便了其他传统类继承语言的程序员能够快速切换到 js 语言环境.而类继承更加直观和简洁,因为转译的实现,js 程序员可以在平时写 js 过程中使用这种更为好用的特性,当然这是一种可选项,类似于 js 语言的行末分号,写的话可能麻烦但是严谨,不写的话代码更加简洁,并能够处理绝大多数情景 (js 引擎自动插入分号而导致) bug.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES2015 的类继承与 ES5 实现类继承的异同</title>
    <link href="http://www.pedclub.com/2016/06/21/ES2015%20Class/"/>
    <id>http://www.pedclub.com/2016/06/21/ES2015 Class/</id>
    <published>2016-06-21T07:34:08.000Z</published>
    <updated>2016-10-22T11:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来看看 ES2015 原生支持的类继承模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现子类对父类的继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    move() &#123;</div><div class="line">        <span class="keyword">this</span>.x += <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.y += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// new一个 Child 类的实例对象</span></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child;</div></pre></td></tr></table></figure>
<p>然后再来看看 ES5 用原型继承来模拟类型继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parents</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 为父对象添加原型方法</span></div><div class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">x, y, color</span>) </span>&#123;</div><div class="line">    <span class="comment">// 在实例化对象时先创建好了 this 对象,然后再调用 Parent 函数</span></div><div class="line">    <span class="comment">// 传入 this ,让 this 得到 Parent 里的静态属性或者方法</span></div><div class="line">    Parent.call(<span class="keyword">this</span>, x, y);</div><div class="line">    <span class="comment">// ES2015 在原生类继承上</span></div><div class="line">    <span class="comment">// 不能在 super 函数执行前,在 this 上添加属性或者静态方法</span></div><div class="line">    <span class="comment">// 原因在于内部实现的不同</span></div><div class="line">    <span class="comment">// ES2015 的子类中的 this 由它将要继承的父类来提供</span></div><div class="line">    <span class="comment">// 再 super 函数调用前,子类中没有 this 对象</span></div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 关键点的实现上有另外一种,区别在于是否会取代 Parent.prototype</span></div><div class="line"><span class="comment">// Child.prtotype.__proto__ = Parent.prototype;</span></div><div class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</div><div class="line"></div><div class="line"><span class="comment">// 手动设置 constructor</span></div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="comment">// 此时完成了子对象对父对象的原型继承</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">45</span>, <span class="string">'green'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 此时的 bar 对象</span></div></pre></td></tr></table></figure>
<p>因为现在 JavaScript 语言有各种高版本的实现,我们可以通过 babel 即可使用 ES2015甚至是 ES2017 的语言特性,而不用考虑浏览器的兼容问题.另外,C#之父在微软领导了 TypeScript 这门语言的实现,这是一门 ES2015 标准的超集,在这之上添加了类型系统,泛型等语言特性,通过使用 TypeScript ,我们可以在编辑器中使用类型推导,这在开发上为我们提供了便利.</p>
<p>接下来我们为了研究类继承与原型继承的异同,先来看看在 TypeScript 中的写法</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    x: number;</div><div class="line">    y: number;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现子类对父类的继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    color: string;</div><div class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    move() &#123;</div><div class="line">        <span class="keyword">this</span>.x += <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.y += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// new一个 Child 类的实例对象</span></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">34</span>, <span class="string">'green'</span>);</div></pre></td></tr></table></figure>
<p>重点来了,接下来我们看转译后的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> __extends = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__extends) || <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 此处将 b 上的静态方法和属性复制到 d 上</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p];</div><div class="line">    <span class="comment">// 一个供内部使用的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = d; &#125;</div><div class="line">    <span class="comment">// Object.create(null) 返回一个真正意义上的空对象</span></div><div class="line">    <span class="comment">// 将传入的 d 的原型对象属性 prototype 赋值为配置好的对象</span></div><div class="line">    <span class="comment">// 这个对象的 constructor 已经配置为 d</span></div><div class="line">    <span class="comment">// 这个对象的 __proto__ 指向了 b 的 原型对象属性 prototype</span></div><div class="line">    d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="keyword">new</span> __());</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 我们看出__extends 函数其实是对子构造函数重新的配置</span></div><div class="line"><span class="comment">// 第一就是将 父构造函数上的静态属性和方法复制到子构造函数上</span></div><div class="line"><span class="comment">// 第二步是将 子构造函数的原型对象属性 prototype 完全重新配置</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Parent;</div><div class="line">&#125;());</div><div class="line"><span class="keyword">var</span> Child = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</div><div class="line">    __extends(Child, _super);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">x, y, color</span>) </span>&#123;</div><div class="line">        _super.call(<span class="keyword">this</span>, x, y);</div><div class="line">        Child.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.x += <span class="number">1</span>;</div><div class="line">            <span class="keyword">this</span>.y += <span class="number">1</span>;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Child;</div><div class="line">&#125;(Parent));</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">34</span>, <span class="string">'green'</span>);</div></pre></td></tr></table></figure>
<p>我们看到代码结构上有些许变化,且在代码头部转译器自动为我们添加了一段对于 __extends 函数的实现.</p>
<p>最后我们来看看精简的原理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 要实现类的继承有以下两步</span></div><div class="line"></div><div class="line"><span class="comment">// Child的实例继承Parent的实例</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(Child.prototype, Parent.prototype);</div><div class="line"></div><div class="line"><span class="comment">// Child继承Parent的静态属性</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(Child, Parent);</div><div class="line"></div><div class="line"><span class="comment">// Object.setPrototypeOf的内部实现</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf = <span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</div><div class="line">  obj.__proto__ = proto;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来看看 ES2015 原生支持的类继承模式&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(x, y) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    say() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现子类对父类的继承&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(x, y, color) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(x, y);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    move() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// new一个 Child 类的实例对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Child;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后再来看看 ES5 用原型继承来模拟类型继承&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parents&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 为父对象添加原型方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Parent.prototype.say = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y, color&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在实例化对象时先创建好了 this 对象,然后再调用 Parent 函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 传入 this ,让 this 得到 Parent 里的静态属性或者方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Parent.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, x, y);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ES2015 在原生类继承上&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 不能在 super 函数执行前,在 this 上添加属性或者静态方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 原因在于内部实现的不同&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ES2015 的子类中的 this 由它将要继承的父类来提供&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 再 super 函数调用前,子类中没有 this 对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 关键点的实现上有另外一种,区别在于是否会取代 Parent.prototype&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Child.prtotype.__proto__ = Parent.prototype;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Child.prototype = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.create(Parent.prototype);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 手动设置 constructor&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Child.prototype.constructor = Child;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此时完成了子对象对父对象的原型继承&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Child(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此时的 bar 对象&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为现在 JavaScript 语言有各种高版本的实现,我们可以通过 babel 即可使用 ES2015甚至是 ES2017 的语言特性,而不用考虑浏览器的兼容问题.另外,C#之父在微软领导了 TypeScript 这门语言的实现,这是一门 ES2015 标准的超集,在这之上添加了类型系统,泛型等语言特性,通过使用 TypeScript ,我们可以在编辑器中使用类型推导,这在开发上为我们提供了便利.&lt;/p&gt;
&lt;p&gt;接下来我们为了研究类继承与原型继承的异同,先来看看在 TypeScript 中的写法&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.pedclub.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>PhotoShop颜色模式入门</title>
    <link href="http://www.pedclub.com/2016/04/13/photoshop-e9-a2-9c-e8-89-b2-e6-a8-a1-e5-bc-8f-e5-85-a5-e9-97-a8/"/>
    <id>http://www.pedclub.com/2016/04/13/photoshop-e9-a2-9c-e8-89-b2-e6-a8-a1-e5-bc-8f-e5-85-a5-e9-97-a8/</id>
    <published>2016-04-13T09:22:16.000Z</published>
    <updated>2016-10-22T11:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开启ps软件之前不妨思考一下这样一个问题，我们的照片或图片，在不同载体上的呈现是否有所不同呢？比如在我们自己的显示器上或者将其在纸张上打印出来，我们是不是观察到了两者在观感上的差异，接下来我将对这些差异背后的原理做一个总结和解释，以供参考。</p>
<h2 id="光与感知的关系"><a href="#光与感知的关系" class="headerlink" title="光与感知的关系"></a>光与感知的关系</h2><p>在我们日常的生活中其实有两种非常不一样的颜色模式，可能大多数人并未去仔细区分二者的异同。具体来说，光的表现形式和日常颜色的表现形式是有所不同的，但二者却又互为一体。听起来是否像个哲学式的命题？可能有点。但无论如何，这本质上其实还是是光在不同情况下的表现，在进入人眼途径上一种是直接进入人眼，另一种则经过反射进入人眼，那么我们接下来具体看看这两种模式的原理和具体表现。</p>
<h2 id="1，加色模式"><a href="#1，加色模式" class="headerlink" title="1，加色模式"></a>1，加色模式</h2><p>我们先来着眼于光在人眼的感知形式，首先我们要确定的一点是，光的颜色模式是“加色模式”。什么是加色模式？光的三原色是“红（Red），绿（Green），蓝（Blue）”，在数值上每种原色用0-255这个区间共256个数值来表示该原色物理层面上显像像素点的亮度，例如：RGB（113,159,66）表示的就是，红色（R）亮度是113个单位，绿色159个单位，而蓝色66个单位，这三种亮度不同的三原色光混合就得到了一块其他色相的光，在我的电脑上这是一块深绿色。</p>
<p><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160413171021-300x200.png" alt="QQ截图20160413171021"></p>
<p>那么加色模式的具体表现就是，在我们将三种不同的光都设置最大值RGB(255,255,255)时，我们会得到一块白色，而最小值RGB（0,0,0）则会得到一块黑色，这种随着色的增加，最终会得到包罗三原色的白色（可分可逆为三原色）的模式，我们将其称作加色模式。</p>
<p><img src="http://www.pedclub.net/wp-content/uploads/2016/04/2000px-Bayer_pattern_on_sensor.svg_-300x195.png" alt="2000px-Bayer_pattern_on_sensor.svg"></p>
<p>或许这有一点反直觉，因为我们在小时候的美术课上将不同颜色颜料混合起来总会得到一块乌黑的颜色，那为什么我们将加色模式的颜色混合起来却得到白色呢？接下来的“减色模式”可能是这个问题的答案。<br><a id="more"></a></p>
<h2 id="2，减色模式"><a href="#2，减色模式" class="headerlink" title="2，减色模式"></a>2，减色模式</h2><p>在日常情况下，我们只要不看那些自发光的物体，譬如说显示器，台灯等时，我们其实生活在一个反射光的世界，也就是说我们日常生活看到的颜色比如杂志书本广告，各种物体等，其实都是是物体表面经过处理过后的光。这个理论是印刷业的基础概念之一，即我们看到的物体颜色并不是这个物体真正的颜色，而是其将光吸收一部分又反射一部分后，那一部分反射的光进入人眼便成了我们对该物体颜色的感知。</p>
<p>例如下图中品红色物体本身就是将绿色光完全吸收后再将红色和蓝色光反射，而红色和蓝色光混合成了什么颜进入人眼呢，对了，那便是品红，因此我们看到了这个物体是品红色。（下图第二个黄光的反射原理有错误，你能发现是哪里错了么？）</p>
<p><img src="http://www.pedclub.net/wp-content/uploads/2016/04/1-3-8-300x117.jpg" alt="1-3-8"><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160413164742-298x300.png" alt="QQ截图20160413164742"></p>
<p>因此我们可以这样总结道，因为存在光直接到达人眼，和光被吸收一部分后再到达人眼这样两种方式，我们就会有两种不同的颜色模式。其本质还是光在不同途径下进入人眼所引起的差异，那么我们调制颜料换句话说就是在调制光反射材料，我们调制特定颜色的颜料就是在调制反射特定光的材料。</p>
<p>我们可能会惊奇的发现加色模式的三原色相互结合得到的便是减色模式的三原色，分别是CMY，即青（Cyan），品红（Magenta），黄（Yellow）。相应的这三原色也有数值表示，但跟RGB不同的是以百分比来表示，而减色这种模式便表现在CMY（0,0,0）在理论上是一块白色（取决于打印纸张本来的颜色），而CMY（100,100,100）在理论上则是一块黑色（因为油墨的不纯净会得到一块更灰的黑色，因此印刷业引入了另外的颜色模式，即“CMYK”，其中的K就是专门的黑色油墨）。这就是减色模式，随着色的增加我们最终会得到“无色”的黑色（无法逆向分为CMY三原色）。</p>
<p><img src="http://www.pedclub.net/wp-content/uploads/2016/04/LcBvQ.gif" alt="LcBvQ"></p>
<p>而这三种颜色在上图中相对的颜色就是他的互补色，在实际表现中，我们将青色（Cyan）的光打到红色（Red）的墙上（注意此处是刷满红色颜料的墙，假设反射的是纯净的红色光），我们会什么也看不到，因为根据上述理论，我们的墙会将蓝色和绿色完全吸收掉，只反射红色光，而蓝色（Blue）和绿色（Green）光的混合便是青（Cyan）。</p>
<h2 id="3，相关"><a href="#3，相关" class="headerlink" title="3，相关"></a>3，相关</h2><p>最后我们来说一些与标题相关的问题，即RGB和CMYK这两种颜色模式在色域上的不同。在下图中，我们会发现RGB和CMYK在颜色域大小方位的不同，这表现在我们在显示屏幕工作下的RGB显示颜色有时候在印刷时并不能完美展现，因为有一些颜色不是二者的交集。因此我们在ps中会有专门的辅助工具，即下面第二幅图片中的三角叹号标志，用以提示我们这个颜色打印时超出色域。</p>
<p><img src="http://www.pedclub.net/wp-content/uploads/2016/04/Farbraumkurve-261x300.jpg" alt="Farbraumkurve"><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160413180111.png" alt="QQ截图20160413180111"></p>
<p>&nbsp;</p>
<p>至此我们基本理清了颜色的关系，更多的颜色理论都是从这里出发的推而广之。我们与光的关系是整个绘画和摄影所着重描绘和表现的，而这门现实中的科学则值得我们不断地探索和实践。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在开启ps软件之前不妨思考一下这样一个问题，我们的照片或图片，在不同载体上的呈现是否有所不同呢？比如在我们自己的显示器上或者将其在纸张上打印出来，我们是不是观察到了两者在观感上的差异，接下来我将对这些差异背后的原理做一个总结和解释，以供参考。&lt;/p&gt;
&lt;h2 id=&quot;光与感知的关系&quot;&gt;&lt;a href=&quot;#光与感知的关系&quot; class=&quot;headerlink&quot; title=&quot;光与感知的关系&quot;&gt;&lt;/a&gt;光与感知的关系&lt;/h2&gt;&lt;p&gt;在我们日常的生活中其实有两种非常不一样的颜色模式，可能大多数人并未去仔细区分二者的异同。具体来说，光的表现形式和日常颜色的表现形式是有所不同的，但二者却又互为一体。听起来是否像个哲学式的命题？可能有点。但无论如何，这本质上其实还是是光在不同情况下的表现，在进入人眼途径上一种是直接进入人眼，另一种则经过反射进入人眼，那么我们接下来具体看看这两种模式的原理和具体表现。&lt;/p&gt;
&lt;h2 id=&quot;1，加色模式&quot;&gt;&lt;a href=&quot;#1，加色模式&quot; class=&quot;headerlink&quot; title=&quot;1，加色模式&quot;&gt;&lt;/a&gt;1，加色模式&lt;/h2&gt;&lt;p&gt;我们先来着眼于光在人眼的感知形式，首先我们要确定的一点是，光的颜色模式是“加色模式”。什么是加色模式？光的三原色是“红（Red），绿（Green），蓝（Blue）”，在数值上每种原色用0-255这个区间共256个数值来表示该原色物理层面上显像像素点的亮度，例如：RGB（113,159,66）表示的就是，红色（R）亮度是113个单位，绿色159个单位，而蓝色66个单位，这三种亮度不同的三原色光混合就得到了一块其他色相的光，在我的电脑上这是一块深绿色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160413171021-300x200.png&quot; alt=&quot;QQ截图20160413171021&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么加色模式的具体表现就是，在我们将三种不同的光都设置最大值RGB(255,255,255)时，我们会得到一块白色，而最小值RGB（0,0,0）则会得到一块黑色，这种随着色的增加，最终会得到包罗三原色的白色（可分可逆为三原色）的模式，我们将其称作加色模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.pedclub.net/wp-content/uploads/2016/04/2000px-Bayer_pattern_on_sensor.svg_-300x195.png&quot; alt=&quot;2000px-Bayer_pattern_on_sensor.svg&quot;&gt;&lt;/p&gt;
&lt;p&gt;或许这有一点反直觉，因为我们在小时候的美术课上将不同颜色颜料混合起来总会得到一块乌黑的颜色，那为什么我们将加色模式的颜色混合起来却得到白色呢？接下来的“减色模式”可能是这个问题的答案。&lt;br&gt;
    
    </summary>
    
      <category term="设计理论" scheme="http://www.pedclub.com/categories/%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>安装虚拟系统备忘</title>
    <link href="http://www.pedclub.com/2016/04/07/VM/"/>
    <id>http://www.pedclub.com/2016/04/07/VM/</id>
    <published>2016-04-07T05:58:08.000Z</published>
    <updated>2016-10-22T11:37:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期临近毕业,毕业设计需要很多在32位机器下才能运行的软件，而很多同学电脑的系统都是64位windows。解决办法自然是去重新再装一个32位的系统，而本人近期又需要很多64位下的工作软件，矛盾就来了，因此不得不找寻另外的途径，于是就有了这篇备忘。</p>
<p>1.首先在这个网站下载安装虚拟机软件<a href="http://rj.baidu.com/soft/detail/13808.html?ald" target="_blank" rel="external">http://rj.baidu.com/soft/detail/13808.html?ald</a></p>
<p>2.然后再在这个网站<a href="http://www.upmobi.cn/ylxp.html" target="_blank" rel="external">http://www.upmobi.cn/ylxp.html</a>下载windows xp 32位系统镜像。（为什么是xp呢，因为相对较小只有700兆，而且经本人测试完美运行各种32位软件。）<br><a id="more"></a></p>
<p>3.安装完毕后，打开VMware Workstation软件，会来到这个界面</p>
<p></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407125903-300x216.png" alt="QQ截图20160407125903"></p>
<ul>
<li><p>点击创建新的虚拟机来到这个界面<br></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407131536-300x256.png" alt="QQ截图20160407131536"></p>
</li>
<li><p>点击典型（推荐），然后下一步，然后来到这个界面<br></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407131744-300x256.png" alt="QQ截图20160407131744"></p>
</li>
<li><p>选择安装程序光盘镜像文件，然后在浏览里打开你下载好的windows xp系统镜像，然后下一步<br></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407132048-300x256.png" alt="QQ截图20160407132048"></p>
</li>
<li><p>按照图中选项选择即可，然后下一步<br></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407132147-300x256.png" alt="QQ截图20160407132147"></p>
</li>
<li><p>按照默认填入就好，直接点击下一步<br></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407132241-300x256.png" alt="QQ截图20160407132241"></p>
</li>
<li><p>按照默认就好，直接点击下一步<br></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407132316-300x256.png" alt="QQ截图20160407132316"></p>
</li>
</ul>
<p></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407132413-300x139.png" alt="QQ截图20160407132413"></p>
<ul>
<li>如果不成功的话，我们先关闭VMware Workstation，再到VMware Workstation软件安装目录下，找到vmware.exe，右键以管理员身份运行，然后重复上面的步骤到此处就可以成功建立虚拟系统引导了<br>接下来点击开启此虚拟机，我们就来到如下界面，<br><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407133120-300x162.png" alt="QQ截图20160407133120"></p></li>
</ul>
<p><ins datetime="2016-04-07T05:25:32+00:00">选择B 启动Win PE光盘系统</ins></p>
<p>我们安装好WinPE后来到系统界面点击<ins datetime="2016-04-07T05:25:32+00:00">硬盘快速分四区</ins></p>
<p></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407133249-300x162.png" alt="QQ截图20160407133249"></p>
<p></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407133317-300x209.png" alt="QQ截图20160407133317"></p>
<p>点击确定，这不会删除本来机器上的数据，这可以看做是个虚拟操作。</p>
<p>分区过程中一路accept就可以。</p>
<p>分区完成后自动提示你安装xp系统，点击确定就可以了，我们就会来到下面这个界面</p>
<p></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407133408-300x162.png" alt="QQ截图20160407133408"></p>
<p>等待进度条完成即可自动重启进入xp系统的安装，到此虚拟系统就安装成功了。</p>
<p></p><p class="aligncenter"><br><img src="http://www.pedclub.net/wp-content/uploads/2016/04/QQ截图20160407133552-300x162.png" alt="QQ截图20160407133552"></p>
<p>安装完毕且进入xp系统后怎样读取到本来文件系统的文件呢，百度有现成的教程”怎样设置虚拟机和主机文件共享”如下</p>
<p><a href="http://jingyan.baidu.com/article/6b1823095583c1ba58e159a8.html" target="_blank" rel="external">http://jingyan.baidu.com/article/6b1823095583c1ba58e159a8.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期临近毕业,毕业设计需要很多在32位机器下才能运行的软件，而很多同学电脑的系统都是64位windows。解决办法自然是去重新再装一个32位的系统，而本人近期又需要很多64位下的工作软件，矛盾就来了，因此不得不找寻另外的途径，于是就有了这篇备忘。&lt;/p&gt;
&lt;p&gt;1.首先在这个网站下载安装虚拟机软件&lt;a href=&quot;http://rj.baidu.com/soft/detail/13808.html?ald&quot;&gt;http://rj.baidu.com/soft/detail/13808.html?ald&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.然后再在这个网站&lt;a href=&quot;http://www.upmobi.cn/ylxp.html&quot;&gt;http://www.upmobi.cn/ylxp.html&lt;/a&gt;下载windows xp 32位系统镜像。（为什么是xp呢，因为相对较小只有700兆，而且经本人测试完美运行各种32位软件。）&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.pedclub.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.pedclub.com/2016/01/14/hello-world/"/>
    <id>http://www.pedclub.com/2016/01/14/hello-world/</id>
    <published>2016-01-14T06:22:49.000Z</published>
    <updated>2016-10-22T11:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo server&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一图搞定关于JavaScript 的原型及函数</title>
    <link href="http://www.pedclub.com/2016/01/14/protoImg/"/>
    <id>http://www.pedclub.com/2016/01/14/protoImg/</id>
    <published>2016-01-14T06:22:49.000Z</published>
    <updated>2016-10-22T17:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="images/Vproto.jpg" alt="Prototype"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;images/Vproto.jpg&quot; alt=&quot;Prototype&quot;&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
