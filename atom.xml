<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pedclub</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.pedclub.com/"/>
  <updated>2016-11-15T11:50:13.000Z</updated>
  <id>http://www.pedclub.com/</id>
  
  <author>
    <name>ped</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一张图搞定关于JavaScript 的原型及函数</title>
    <link href="http://www.pedclub.com/2016/10/23/protoImg/"/>
    <id>http://www.pedclub.com/2016/10/23/protoImg/</id>
    <published>2016-10-22T17:39:18.000Z</published>
    <updated>2016-11-15T11:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Vproto.jpg" alt="Prototype"></p>
<h4 id="由图可知"><a href="#由图可知" class="headerlink" title="由图可知"></a>由图可知</h4><ol>
<li>图中的所有实例除了<code>null</code>以外都有 <code>__proto__</code> 这个属性.</li>
<li><code>Function</code> 构造函数的原型属性的类型并不是<code>object</code>类型, 而是一个<code>function</code>类型.</li>
<li>构造函数的<code>__proto__</code>属性都指向<code>Function</code>的原型对象, 包括<code>Function</code>自己.<a id="more"></a></li>
<li>原型对象的<code>__proto__</code>属性都指向<code>Object</code>的原型对象, 除了<code>Object</code>的原型对象指向<code>null</code>以外.</li>
<li>对象实例的<code>__proto__</code>属性都指向其构造函数的原型对象.    </li>
<li><code>__proto__</code>属性是 JavaScript 语言实现原型继承的根本</li>
<li><code>null</code>的类型是<code>object</code>是设计失误</li>
</ol>
<div class="tip"><br>因为每个构造函数上的原型对象属性<code>prototype</code>类似于指针这个概念, 因此要区分清楚当我们更改了<code>prototype</code>的指向后, 并没有随之更改已经由构造函数先前创建好的实例对象中所指向的原型对象, 这个动作导致了构造函数所指原型对象与在这之前构造函数<code>new</code>创建的实例中<code>__proto__</code>所指向的原型对象这两者的不同<br></div>



]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Vproto.jpg&quot; alt=&quot;Prototype&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;由图可知&quot;&gt;&lt;a href=&quot;#由图可知&quot; class=&quot;headerlink&quot; title=&quot;由图可知&quot;&gt;&lt;/a&gt;由图可知&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;图中的所有实例除了&lt;code&gt;null&lt;/code&gt;以外都有 &lt;code&gt;__proto__&lt;/code&gt; 这个属性.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function&lt;/code&gt; 构造函数的原型属性的类型并不是&lt;code&gt;object&lt;/code&gt;类型, 而是一个&lt;code&gt;function&lt;/code&gt;类型.&lt;/li&gt;
&lt;li&gt;构造函数的&lt;code&gt;__proto__&lt;/code&gt;属性都指向&lt;code&gt;Function&lt;/code&gt;的原型对象, 包括&lt;code&gt;Function&lt;/code&gt;自己.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Angular的启动过程揭秘</title>
    <link href="http://www.pedclub.com/2016/10/17/prototype/"/>
    <id>http://www.pedclub.com/2016/10/17/prototype/</id>
    <published>2016-10-17T11:37:01.000Z</published>
    <updated>2016-11-15T12:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于 JavaScript 的类继承</title>
    <link href="http://www.pedclub.com/2016/06/21/ES2015%20Class/"/>
    <id>http://www.pedclub.com/2016/06/21/ES2015 Class/</id>
    <published>2016-06-21T07:34:08.000Z</published>
    <updated>2016-11-15T12:10:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 js 这门语言向前发展过程中, 我们发现不管是最新确立的 <code>ES2015</code> 还是 <code>TypeScript</code> 都在 js 面向对象这一语言特性上做了一定程度的转变, 都能通过转译使用原型继承实现’类继承’这个语法糖. 这在某种意义上对原型继承模式的封装,方便了其他传统类继承语言的程序员能够快速切换到 js 语言环境. 而类继承本身较原型继承更加直观和简洁, 因为当下各种转译器的实现, js 程序员可以在平时开发过程中选择使用这种更为好用的特性.</p>
<h3 id="ES2015-与-ES5"><a href="#ES2015-与-ES5" class="headerlink" title="ES2015 与 ES5 ???"></a>ES2015 与 ES5 ???</h3><p>先来看看最新确立的 <code>JavaScript</code> 语言标准 <code>ES2015</code> 原生支持的类继承语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现子类对父类的继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">        <span class="comment">// ES2015 在原生类继承上</span></div><div class="line">        <span class="comment">// 不能在 super 执行前,在 this 上添加属性或者方法</span></div><div class="line">        <span class="comment">// 原因在于 ES2015 的子类中的 this 由它将要继承的父类来提供</span></div><div class="line">        <span class="comment">// 在 super 调用前, 子类中没有 this 对象, 强行添加属性会报语法错</span></div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    move() &#123;</div><div class="line">        <span class="keyword">this</span>.x += <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.y += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// new一个 Child 类的实例对象</span></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child;</div></pre></td></tr></table></figure>
<p>而在 <code>ES5</code> 中, 我们可以通过用原型继承来模拟类型继承, 这其实就是组合继承模式, 也叫伪经典继承. 背后的思路是</p>
<blockquote>
<ol>
<li>使用原型链实现对父构造函数原型对象上方法和属性的继承</li>
<li>使用借用构造函数的方式实现对父构造函数实例属性的继承.</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parents</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 为父构造函数添加原型方法</span></div><div class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">x, y, color</span>) </span>&#123;</div><div class="line">    <span class="comment">// 在实例化对象时先创建好了 this 对象,然后再调用 Parent 函数</span></div><div class="line">    <span class="comment">// 传入 this ,让 this 得到 Parent 里的实例属性或者实例方法</span></div><div class="line">    Parent.call(<span class="keyword">this</span>, x, y);</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 此处关键点的实现上有另外一种,区别在于是否会取代 Parent.prototype</span></div><div class="line"><span class="comment">// Child.prtotype.__proto__ = Parent.prototype;</span></div><div class="line"></div><div class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</div><div class="line"></div><div class="line"><span class="comment">// 手动恢复 constructor</span></div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="comment">// 此时完成了原型继承</span></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">45</span>, <span class="string">'green'</span>);</div></pre></td></tr></table></figure>
<h3 id="TypeScript-的实现"><a href="#TypeScript-的实现" class="headerlink" title="TypeScript 的实现"></a>TypeScript 的实现</h3><p>现在 <code>JavaScript</code> 语言有各种更高版本的实现, 我们可以通过 <code>babel</code> 使用 <code>ES2015</code> 甚至是 <code>ES2017</code> 的语言特性, 而不用考虑浏览器的兼容问题. 此外, 在微软的 <code>C#</code> 之父 <code>Anders Hejlsberg</code> 领导了 <code>TypeScript</code> 的实现, 这门语言是 ES2015 标准的超集, 并在此之上添加了类型系统, 泛型等语言特性, 通过使用 <code>TypeScript</code> , 我们可以在编辑器中使用类型推导, 这在开发上为我们提供了便利, 尤其是对那些有强类型语言背景的人来说.</p>
<p>在 TypeScript 中的类继承语法如下.</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    x: number;</div><div class="line">    y: number;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现子类对父类的继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    color: string;</div><div class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    move() &#123;</div><div class="line">        <span class="keyword">this</span>.x += <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.y += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// new一个 Child 类的实例对象</span></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">34</span>, <span class="string">'green'</span>);</div></pre></td></tr></table></figure>
<p>重点在于通过查看转译后的代码, 我们发现在代码最顶部转译器自动为我们添加了一段对于 <code>__extends</code> 函数的实现. <code>__extends</code>函数最主要的作用在于帮助我们自动完成对子构造函数的重新配置, 主要有两步.</p>
<blockquote>
<ol>
<li>将父构造函数上的静态属性和静态方法复制到子构造函数上</li>
<li>将子构造函数的原型对象属性 <code>prototype</code> 完全重新配置<br>PS: Object.create(null) 返回一个真正意义上的空对象</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> __extends = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__extends) || <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 此处将 b 上的静态方法和属性复制到 d 上</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p];</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = d; &#125;</div><div class="line">    d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="keyword">new</span> __());</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Parent;</div><div class="line">&#125;());</div><div class="line"></div><div class="line"><span class="keyword">var</span> Child = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</div><div class="line">    <span class="comment">// 1. 完成对静态方法和静态属性的继承</span></div><div class="line">    <span class="comment">// 2. 完成对原型方法和原型属性的继承</span></div><div class="line">    __extends(Child, _super);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">x, y, color</span>) </span>&#123;</div><div class="line">        <span class="comment">// 3. 此处完成对实例属性和实例方法的继承</span></div><div class="line">        _super.call(<span class="keyword">this</span>, x, y);</div><div class="line">        Child.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.x += <span class="number">1</span>;</div><div class="line">            <span class="keyword">this</span>.y += <span class="number">1</span>;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Child;</div><div class="line">&#125;(Parent));</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">34</span>, <span class="string">'green'</span>);</div></pre></td></tr></table></figure>
<p>我们发现 <code>TypeScript</code> 为我们完成了对父构造函数(父类)上静态属性或方法的继承, 比用组合继承多走了一步, 实际上这种实现也更加合理, 更加像类继承.</p>
<h3 id="精简实现"><a href="#精简实现" class="headerlink" title="精简实现"></a>精简实现</h3><p>最后我们来看看精简的原理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 要实现类的继承有以下两步</span></div><div class="line"></div><div class="line"><span class="comment">// Child 的实例继承 Parent 的实例</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(Child.prototype, Parent.prototype);</div><div class="line"></div><div class="line"><span class="comment">// Child 继承 Parent 的静态属性</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(Child, Parent);</div><div class="line"></div><div class="line"><span class="comment">// Object.setPrototypeOf的内部实现</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf = <span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</div><div class="line">  obj.__proto__ = proto;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 js 这门语言向前发展过程中, 我们发现不管是最新确立的 &lt;code&gt;ES2015&lt;/code&gt; 还是 &lt;code&gt;TypeScript&lt;/code&gt; 都在 js 面向对象这一语言特性上做了一定程度的转变, 都能通过转译使用原型继承实现’类继承’这个语法糖. 这在某种意义上对原型继承模式的封装,方便了其他传统类继承语言的程序员能够快速切换到 js 语言环境. 而类继承本身较原型继承更加直观和简洁, 因为当下各种转译器的实现, js 程序员可以在平时开发过程中选择使用这种更为好用的特性.&lt;/p&gt;
&lt;h3 id=&quot;ES2015-与-ES5&quot;&gt;&lt;a href=&quot;#ES2015-与-ES5&quot; class=&quot;headerlink&quot; title=&quot;ES2015 与 ES5 ???&quot;&gt;&lt;/a&gt;ES2015 与 ES5 ???&lt;/h3&gt;&lt;p&gt;先来看看最新确立的 &lt;code&gt;JavaScript&lt;/code&gt; 语言标准 &lt;code&gt;ES2015&lt;/code&gt; 原生支持的类继承语法&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(x, y) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    say() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现子类对父类的继承&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(x, y, color) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ES2015 在原生类继承上&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 不能在 super 执行前,在 this 上添加属性或者方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 原因在于 ES2015 的子类中的 this 由它将要继承的父类来提供&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 在 super 调用前, 子类中没有 this 对象, 强行添加属性会报语法错&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(x, y);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    move() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// new一个 Child 类的实例对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Child;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而在 &lt;code&gt;ES5&lt;/code&gt; 中, 我们可以通过用原型继承来模拟类型继承, 这其实就是组合继承模式, 也叫伪经典继承. 背后的思路是&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;使用原型链实现对父构造函数原型对象上方法和属性的继承&lt;/li&gt;
&lt;li&gt;使用借用构造函数的方式实现对父构造函数实例属性的继承.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parents&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 为父构造函数添加原型方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Parent.prototype.say = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y, color&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在实例化对象时先创建好了 this 对象,然后再调用 Parent 函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 传入 this ,让 this 得到 Parent 里的实例属性或者实例方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Parent.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, x, y);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此处关键点的实现上有另外一种,区别在于是否会取代 Parent.prototype&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Child.prtotype.__proto__ = Parent.prototype;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Child.prototype = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.create(Parent.prototype);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 手动恢复 constructor&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Child.prototype.constructor = Child;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此时完成了原型继承&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Child(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;TypeScript-的实现&quot;&gt;&lt;a href=&quot;#TypeScript-的实现&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 的实现&quot;&gt;&lt;/a&gt;TypeScript 的实现&lt;/h3&gt;&lt;p&gt;现在 &lt;code&gt;JavaScript&lt;/code&gt; 语言有各种更高版本的实现, 我们可以通过 &lt;code&gt;babel&lt;/code&gt; 使用 &lt;code&gt;ES2015&lt;/code&gt; 甚至是 &lt;code&gt;ES2017&lt;/code&gt; 的语言特性, 而不用考虑浏览器的兼容问题. 此外, 在微软的 &lt;code&gt;C#&lt;/code&gt; 之父 &lt;code&gt;Anders Hejlsberg&lt;/code&gt; 领导了 &lt;code&gt;TypeScript&lt;/code&gt; 的实现, 这门语言是 ES2015 标准的超集, 并在此之上添加了类型系统, 泛型等语言特性, 通过使用 &lt;code&gt;TypeScript&lt;/code&gt; , 我们可以在编辑器中使用类型推导, 这在开发上为我们提供了便利, 尤其是对那些有强类型语言背景的人来说.&lt;/p&gt;
&lt;p&gt;在 TypeScript 中的类继承语法如下.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.pedclub.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>PhotoShop颜色模式入门</title>
    <link href="http://www.pedclub.com/2016/04/13/photoshop-e9-a2-9c-e8-89-b2-e6-a8-a1-e5-bc-8f-e5-85-a5-e9-97-a8/"/>
    <id>http://www.pedclub.com/2016/04/13/photoshop-e9-a2-9c-e8-89-b2-e6-a8-a1-e5-bc-8f-e5-85-a5-e9-97-a8/</id>
    <published>2016-04-13T09:22:16.000Z</published>
    <updated>2016-11-10T15:33:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开启ps软件之前不妨思考一下这样一个问题，我们的照片或图片，在不同载体上的呈现是否有所不同呢？比如在我们自己的显示器上或者将其在纸张上打印出来，我们是不是观察到了两者在观感上的差异，接下来我将对这些差异背后的原理做一个总结和解释，以供参考。</p>
<h2 id="光与感知的关系"><a href="#光与感知的关系" class="headerlink" title="光与感知的关系"></a>光与感知的关系</h2><p>在我们日常的生活中其实有两种非常不一样的颜色模式，可能大多数人并未去仔细区分二者的异同。具体来说，光的表现形式和日常颜色的表现形式是有所不同的，但二者却又互为一体。听起来是否像个哲学式的命题？可能有点。但无论如何，这本质上其实还是是光在不同情况下的表现，在进入人眼途径上一种是直接进入人眼，另一种则经过反射进入人眼，那么我们接下来具体看看这两种模式的原理和具体表现。</p>
<h2 id="1，加色模式"><a href="#1，加色模式" class="headerlink" title="1，加色模式"></a>1，加色模式</h2><p>我们先来着眼于光在人眼的感知形式，首先我们要确定的一点是，光的颜色模式是“加色模式”。什么是加色模式？光的三原色是“红<code>（Red）</code>，绿<code>（Green）</code>，蓝<code>（Blue）</code>”，在数值上每种原色用<code>0-255</code>这个区间共<code>256</code>个数值来表示该原色物理层面上显像像素点的亮度，例如：<code>RGB（113,159,66</code>）表示的就是，红色（R）亮度是113个单位，绿色159个单位，而蓝色66个单位，这三种亮度不同的三原色光混合就得到了一块其他色相的光，在我的电脑上这是一块深绿色。</p>
<p><img src="/images/2016041317.png" alt="20160413171021"></p>
<p>那么加色模式的具体表现就是，在我们将三种不同的光都设置最大值<code>RGB(255,255,255)</code>时，我们会得到一块白色，而最小值<code>RGB（0,0,0）</code>则会得到一块黑色，这种随着色的增加，最终会得到包罗三原色的白色（可分可逆为三原色）的模式，我们将其称作加色模式。</p>
<p><img src="/images/2000pxBayer.png" alt="Bayer_pattern_on_sensor.svg"></p>
<p>或许这有一点反直觉，因为我们在小时候的美术课上将不同颜色颜料混合起来总会得到一块乌黑的颜色，那为什么我们将加色模式的颜色混合起来却得到白色呢？接下来的“减色模式”可能是这个问题的答案。<br><a id="more"></a></p>
<h2 id="2，减色模式"><a href="#2，减色模式" class="headerlink" title="2，减色模式"></a>2，减色模式</h2><p>在日常情况下，我们只要不看那些自发光的物体，譬如说显示器，台灯等时，我们其实生活在一个反射光的世界，也就是说我们日常生活看到的颜色比如杂志书本广告，各种物体等，其实都是是物体表面经过处理过后的光。这个理论是印刷业的基础概念之一，即我们看到的物体颜色并不是这个物体真正的颜色，而是其将光吸收一部分又反射一部分后，那一部分反射的光进入人眼便成了我们对该物体颜色的感知。</p>
<p>例如下图中品红色物体本身就是将绿色光完全吸收后再将红色和蓝色光反射，而红色和蓝色光混合成了什么颜进入人眼呢，对了，那便是品红，因此我们看到了这个物体是品红色。（下图第二个黄光的反射原理有错误，你能发现是哪里错了么？）</p>
<p><img src="/images/three.jpg" alt="18"><br><img src="/images/2016041316.png" alt="20160413164742"></p>
<p>因此我们可以这样总结道，因为存在光直接到达人眼，和光被吸收一部分后再到达人眼这样两种方式，我们就会有两种不同的颜色模式。其本质还是光在不同途径下进入人眼所引起的差异，那么我们调制颜料换句话说就是在调制光反射材料，我们调制特定颜色的颜料就是在调制反射特定光的材料。</p>
<p>我们可能会惊奇的发现加色模式的三原色相互结合得到的便是减色模式的三原色，分别是<code>CMY</code>，即青（<code>Cyan</code>），品红<code>（Magenta）</code>，黄<code>（Yellow）</code>。相应的这三原色也有数值表示，但跟<code>RGB</code>不同的是以百分比来表示，而减色这种模式便表现在CMY（0,0,0）在理论上是一块白色（取决于打印纸张本来的颜色），而CMY（100,100,100）在理论上则是一块黑色（因为油墨的不纯净会得到一块更灰的黑色，因此印刷业引入了另外的颜色模式，即<code>CMYK</code>，其中的K就是专门的黑色油墨）。这就是减色模式，随着色的增加我们最终会得到“无色”的黑色（无法逆向分为<code>CMY</code>三原色）。</p>
<p><img src="/images/LcBvQ.gif" alt="LcBvQ"></p>
<p>而这三种颜色在上图中相对的颜色就是他的互补色，在实际表现中，我们将青色<code>（Cyan）</code>的光打到红色<code>（Red）</code>的墙上（注意此处是刷满红色颜料的墙，假设反射的是纯净的红色光），我们会什么也看不到，因为根据上述理论，我们的墙会将蓝色和绿色完全吸收掉，只反射红色光，而蓝色（Blue）和绿色（Green）光的混合便是青<code>（Cyan）</code>。</p>
<h2 id="3，相关"><a href="#3，相关" class="headerlink" title="3，相关"></a>3，相关</h2><p>最后我们来说一些与标题相关的问题，即RGB和CMYK这两种颜色模式在色域上的不同。在下图中，我们会发现RGB和CMYK在颜色域大小方位的不同，这表现在我们在显示屏幕工作下的RGB显示颜色有时候在印刷时并不能完美展现，因为有一些颜色不是二者的交集。因此我们在ps中会有专门的辅助工具，即下面第二幅图片中的三角叹号标志，用以提示我们这个颜色打印时超出色域。</p>
<p><img src="/images/Farbraumkurve.jpg" alt="Farbraumkurve"><br><img src="/images/2016041318.png" alt="20160413180111"></p>
<p>&nbsp;</p>
<p>至此我们基本理清了颜色的关系，更多的颜色理论都是从这里出发的推而广之。我们与光的关系是整个绘画和摄影所着重描绘和表现的，而这门现实中的科学则值得我们不断地探索和实践。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在开启ps软件之前不妨思考一下这样一个问题，我们的照片或图片，在不同载体上的呈现是否有所不同呢？比如在我们自己的显示器上或者将其在纸张上打印出来，我们是不是观察到了两者在观感上的差异，接下来我将对这些差异背后的原理做一个总结和解释，以供参考。&lt;/p&gt;
&lt;h2 id=&quot;光与感知的关系&quot;&gt;&lt;a href=&quot;#光与感知的关系&quot; class=&quot;headerlink&quot; title=&quot;光与感知的关系&quot;&gt;&lt;/a&gt;光与感知的关系&lt;/h2&gt;&lt;p&gt;在我们日常的生活中其实有两种非常不一样的颜色模式，可能大多数人并未去仔细区分二者的异同。具体来说，光的表现形式和日常颜色的表现形式是有所不同的，但二者却又互为一体。听起来是否像个哲学式的命题？可能有点。但无论如何，这本质上其实还是是光在不同情况下的表现，在进入人眼途径上一种是直接进入人眼，另一种则经过反射进入人眼，那么我们接下来具体看看这两种模式的原理和具体表现。&lt;/p&gt;
&lt;h2 id=&quot;1，加色模式&quot;&gt;&lt;a href=&quot;#1，加色模式&quot; class=&quot;headerlink&quot; title=&quot;1，加色模式&quot;&gt;&lt;/a&gt;1，加色模式&lt;/h2&gt;&lt;p&gt;我们先来着眼于光在人眼的感知形式，首先我们要确定的一点是，光的颜色模式是“加色模式”。什么是加色模式？光的三原色是“红&lt;code&gt;（Red）&lt;/code&gt;，绿&lt;code&gt;（Green）&lt;/code&gt;，蓝&lt;code&gt;（Blue）&lt;/code&gt;”，在数值上每种原色用&lt;code&gt;0-255&lt;/code&gt;这个区间共&lt;code&gt;256&lt;/code&gt;个数值来表示该原色物理层面上显像像素点的亮度，例如：&lt;code&gt;RGB（113,159,66&lt;/code&gt;）表示的就是，红色（R）亮度是113个单位，绿色159个单位，而蓝色66个单位，这三种亮度不同的三原色光混合就得到了一块其他色相的光，在我的电脑上这是一块深绿色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2016041317.png&quot; alt=&quot;20160413171021&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么加色模式的具体表现就是，在我们将三种不同的光都设置最大值&lt;code&gt;RGB(255,255,255)&lt;/code&gt;时，我们会得到一块白色，而最小值&lt;code&gt;RGB（0,0,0）&lt;/code&gt;则会得到一块黑色，这种随着色的增加，最终会得到包罗三原色的白色（可分可逆为三原色）的模式，我们将其称作加色模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2000pxBayer.png&quot; alt=&quot;Bayer_pattern_on_sensor.svg&quot;&gt;&lt;/p&gt;
&lt;p&gt;或许这有一点反直觉，因为我们在小时候的美术课上将不同颜色颜料混合起来总会得到一块乌黑的颜色，那为什么我们将加色模式的颜色混合起来却得到白色呢？接下来的“减色模式”可能是这个问题的答案。&lt;br&gt;
    
    </summary>
    
      <category term="设计理论" scheme="http://www.pedclub.com/categories/%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>对querySelectorAll 的一些区分</title>
    <link href="http://www.pedclub.com/2016/02/14/%E5%85%B3%E4%BA%8EquerySelectorAll%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%86/"/>
    <id>http://www.pedclub.com/2016/02/14/关于querySelectorAll 的一些区分/</id>
    <published>2016-02-14T03:32:23.000Z</published>
    <updated>2016-11-15T12:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一年多以前我在入门前端的时候学到 <code>querySelectorAll</code> 这个<code>API</code>时有一个疑问, 如此强大的 js 选择器方法并且老早就标准化的<code>API</code>(在浏览器端支持到 IE8+), 为什么在网上很难看到其他人在使用, 经过对 <code>JavaScript DOM</code>特性的深入了解和查阅一些资料, 才发现自己对 DOM 的一些概念没有加以深刻的区分, 今天在此基础上对这个方法做一个总结.</p>
<h2 id="类型上的区分"><a href="#类型上的区分" class="headerlink" title="类型上的区分"></a>类型上的区分</h2><p>说到 <code>querySelector()</code>和 <code>querySelectorAll()</code> 这两个方法, 首先要明确的是它是 W3C 组织对 <code>DOM API</code> 的专有扩展, 名叫 <code>Selectors API Level 1</code>, 与 <code>getElementsBy*</code> 系列分属不同的 API 集合, 扩展方法得以成为标准得益于 JS 社区面对频繁繁琐的 DOM 操作实现的各种选择器轮子, 最出名的当属从 <code>jQuery</code> 中独立出的 <code>Sizzle</code>.</p>
<p>随着移动端在互联网终端份额中独占鳌头, 移动前端开发者迫切需要一个轻量级不需要考虑 PC Web 端那么多历史遗留问题的类<code>jQuery</code>库, <code>Zepto</code>应运而生, 就其内部选择器的实现上比 jQuery 的选择器模块小很多, 这是其轻量的重要原因之一, 下面的代码就是 <code>Zepto 0.8</code> 版本的选择器模块.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// $$ 核心选择器函数</span></div><div class="line">$.qsa = $$ = <span class="function"><span class="keyword">function</span>(<span class="params">element, selector</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> found;</div><div class="line">    <span class="comment">// 匹配id选择器</span></div><div class="line">    <span class="keyword">return</span> (element === <span class="built_in">document</span> &amp;&amp; idSelectorRE.test(selector)) ?</div><div class="line">        ((found = element.getElementById(<span class="built_in">RegExp</span>.$<span class="number">1</span>)) ? [found] : emptyArray) :</div><div class="line">        slice.call(</div><div class="line">            <span class="comment">// 匹配 .className 类选择器</span></div><div class="line">            classSelectorRE.test(selector) ? element.getElementsByClassName(<span class="built_in">RegExp</span>.$<span class="number">1</span>) :</div><div class="line">            <span class="comment">// 匹配 div 标签选择器</span></div><div class="line">            tagSelectorRE.test(selector) ? element.getElementsByTagName(selector) :</div><div class="line">            <span class="comment">// 都不匹配就 传入到 querySelectorAll() 方法来选择 dom 元素</span></div><div class="line">            element.querySelectorAll(selector)</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Zepto</code> 在 <code>0.8</code> 版本之后选择器架构上做了一些升级, 但大概的设计原则没有变, 就是能用 <code>getElementsBy*</code> 系列的就尽量不使用 <code>querySelectorAll</code><br><a id="more"></a></p>
<h2 id="取得元素的类型区分"><a href="#取得元素的类型区分" class="headerlink" title="取得元素的类型区分"></a>取得元素的类型区分</h2><p>这两种 API 在取得的元素上有什么区分呢, 看代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            middle</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>)</div><div class="line"><span class="built_in">console</span>.log(divs.length)    <span class="comment">// 5</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>))</div><div class="line"><span class="built_in">console</span>.log(divs.length)    <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> divs2 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)</div><div class="line"><span class="built_in">console</span>.log(divs2.length)   <span class="comment">// 6</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>))</div><div class="line"><span class="built_in">console</span>.log(divs2.length)   <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p>我们发现 <code>querySelectorAll</code> 取得的元素集合好像不会动态增加, 而 <code>getElementsByTagName</code> 取得的却可以, 原因是这两种方法取得的元素集合在类型上的不同, 因而在其表现上就不同. <code>querySelectorAll</code> 取得的是一种叫做 <code>static NodeList</code> 的’静态’集合, 更像是文档片断的快照, 而<code>getElementsByTagName</code>取得的是叫做 <code>HTMLCollection</code> 的一种’动态’集合’, 文档实时的添加元素会反映到当前集合中. 这种区分是在 W3C 规范中加以明确区分的, 在日常开发中, 两者的分别导致的影响并不大, 尤其是在使用类库的一些<code>dom</code>操作 API 时, 类库帮我们除去了一些意料之外的坑.</p>
<div class="tip"><br>注意: 这两种集合都是一个类数组对象, 上面的区分只反应在集合这个尺度上, 在集合中的每个具体元素有它们各自的类型, 如果我们修改集合中具体元素的特性, 是会同步到元素本身上的, 这一点要加以区分<br></div>


<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>这两者除了在本身类型和取得元素类型上的区分, 另外一个有更大实际影响的区分, 就是两者在选择元素性能上的区别. 可以说在选择性能上<code>getElementsByTagName()</code> 比 <code>querySelectorAll()</code> 快100倍, 这种性能级别的差距让人出乎意料, 也不难解释 <code>Zepto</code> 的核心选择器模块不都使用 <code>querySelectorAll</code> 来实现元素的选择.</p>
<p>究竟是什么原因导致这种性能差距呢, 这不得不从两者选择元素的方式上说起.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"warning"</span>&gt;</span>This is a sample warning<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>This is a sample error<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bar"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 querySelectorAll</span></div><div class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>)</div><div class="line"><span class="built_in">console</span>.log(foo.querySelectorAll(<span class="string">"div &gt; p"</span>).length) <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 jquery</span></div><div class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>)</div><div class="line"><span class="built_in">console</span>.log(($(foo).find(“div &gt; p”).length) <span class="comment">//0</span></div></pre></td></tr></table></figure>
<p>值得注意的是我们在取到 <code>foo</code> 这个 <code>div</code> 元素后再利用子代选择器选择这个 <code>div</code> 中的所有 <code>p</code> 元素, 我们发现这两种方式选择到的元素集合有差别.</p>
<p>在 jquery 中使用 find 方法是基于当前调用元素作为 <code>context</code> 上下文来对元素进行选择, 因为 <code>foo</code> 这个 <code>div</code> 作为上下文, 其中并没有一个 <code>div</code> 用来匹配 jquery 中的子代选择器, 所以选择不到 <code>p</code>元素</p>
<p>而 <code>querySelectorAll</code> 在选择上下文上是按照 W3C 的规范实现的, 并不会管其当前调用元素, 它的选择方式是先在整个文档中来进行上下文查找的, 在整个文档中匹配完后, 再去根据当前调用元素进行限定过滤, 因此我们先在文档中选择得到了元素 <code>p</code> 集合, 然后再与<code>foo</code> 这个 <code>div</code>的内部进行对比, 符合就返回, 不符合就过滤掉.</p>
<p>选择方式的差别是性能的差别的其中一个因素, 在更进一步的内部实现原理上我们才可以一窥其性能差别的主要原因.</p>
<p>在浏览器内部, 我们每当要取一个静态的<code>NodeList</code>实例, 都先会去创建一个新的对象 ,然后读取所有当前<code>dom</code>对象的数据填充到这个新的对象中去, 而在获取动态的<code>NodeList</code>实例或<code>HTMLCollection</code>等’动态’集合时, 浏览器直接从文档缓存中获取当前<code>dom</code>对象进行一一映射返回, 不需要任何前期的构造, 对比静态的<code>NodeList</code>实例的创建少了大量额外的前期工作.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一年多以前我在入门前端的时候学到 &lt;code&gt;querySelectorAll&lt;/code&gt; 这个&lt;code&gt;API&lt;/code&gt;时有一个疑问, 如此强大的 js 选择器方法并且老早就标准化的&lt;code&gt;API&lt;/code&gt;(在浏览器端支持到 IE8+), 为什么在网上很难看到其他人在使用, 经过对 &lt;code&gt;JavaScript DOM&lt;/code&gt;特性的深入了解和查阅一些资料, 才发现自己对 DOM 的一些概念没有加以深刻的区分, 今天在此基础上对这个方法做一个总结.&lt;/p&gt;
&lt;h2 id=&quot;类型上的区分&quot;&gt;&lt;a href=&quot;#类型上的区分&quot; class=&quot;headerlink&quot; title=&quot;类型上的区分&quot;&gt;&lt;/a&gt;类型上的区分&lt;/h2&gt;&lt;p&gt;说到 &lt;code&gt;querySelector()&lt;/code&gt;和 &lt;code&gt;querySelectorAll()&lt;/code&gt; 这两个方法, 首先要明确的是它是 W3C 组织对 &lt;code&gt;DOM API&lt;/code&gt; 的专有扩展, 名叫 &lt;code&gt;Selectors API Level 1&lt;/code&gt;, 与 &lt;code&gt;getElementsBy*&lt;/code&gt; 系列分属不同的 API 集合, 扩展方法得以成为标准得益于 JS 社区面对频繁繁琐的 DOM 操作实现的各种选择器轮子, 最出名的当属从 &lt;code&gt;jQuery&lt;/code&gt; 中独立出的 &lt;code&gt;Sizzle&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;随着移动端在互联网终端份额中独占鳌头, 移动前端开发者迫切需要一个轻量级不需要考虑 PC Web 端那么多历史遗留问题的类&lt;code&gt;jQuery&lt;/code&gt;库, &lt;code&gt;Zepto&lt;/code&gt;应运而生, 就其内部选择器的实现上比 jQuery 的选择器模块小很多, 这是其轻量的重要原因之一, 下面的代码就是 &lt;code&gt;Zepto 0.8&lt;/code&gt; 版本的选择器模块.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// $$ 核心选择器函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$.qsa = $$ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;element, selector&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; found;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 匹配id选择器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (element === &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt; &amp;amp;&amp;amp; idSelectorRE.test(selector)) ?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ((found = element.getElementById(&lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;.$&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) ? [found] : emptyArray) :&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        slice.call(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 匹配 .className 类选择器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            classSelectorRE.test(selector) ? element.getElementsByClassName(&lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;.$&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) :&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 匹配 div 标签选择器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            tagSelectorRE.test(selector) ? element.getElementsByTagName(selector) :&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 都不匹配就 传入到 querySelectorAll() 方法来选择 dom 元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            element.querySelectorAll(selector)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Zepto&lt;/code&gt; 在 &lt;code&gt;0.8&lt;/code&gt; 版本之后选择器架构上做了一些升级, 但大概的设计原则没有变, 就是能用 &lt;code&gt;getElementsBy*&lt;/code&gt; 系列的就尽量不使用 &lt;code&gt;querySelectorAll&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.pedclub.com/2016/01/14/hello-world/"/>
    <id>http://www.pedclub.com/2016/01/14/hello-world/</id>
    <published>2016-01-14T06:22:49.000Z</published>
    <updated>2016-10-22T11:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo server&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
