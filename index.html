<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Pedclub</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.pedclub.com/atom.xml" title="Pedclub"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2020592511/home?topnav=1&amp;wvr=5" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/PEDx" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/23/protoImg/" class="post-title-link">一张图搞定关于JavaScript 的原型及函数</a></h2><div class="post-info">Oct 23, 2016</div><div class="post-content"><p><img src="/images/Vproto.jpg" alt="Prototype"></p></div><a href="/2016/10/23/protoImg/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/17/prototype/" class="post-title-link">JavaScript对象及原型链</a></h2><div class="post-info">Oct 17, 2016</div><div class="post-content"><p>在 js 这门语言向前发展过程中.我们发现不管是最新确立的 ES2015 还是 TypeScript 都在 js 面向对象这一语言特性上做了一定程度的改变,转译后都把 js 原型继承用来实现了新版本语言特性中的类继承,而不是用 js 原生的面向对象特性.这在某种意义上对原型继承模式的封装,方便了其他传统类继承语言的程序员能够快速切换到 js 语言环境.而类继承更加直观和简洁,因为转译的实现,js 程序员可以在平时写 js 过程中使用这种更为好用的特性,当然这是一种可选项,类似于 js 语言的行末分号,写的话可能麻烦但是严谨,不写的话代码更加简洁,并能够处理绝大多数情景 (js 引擎自动插入分号而导致) bug.</p></div><a href="/2016/10/17/prototype/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/06/21/ES2015 Class/" class="post-title-link">关于 JavaScript 的类继承</a></h2><div class="post-info">Jun 21, 2016</div><div class="post-content"><h3 id="ES2015-与-ES5"><a href="#ES2015-与-ES5" class="headerlink" title="ES2015 与 ES5 ???"></a>ES2015 与 ES5 ???</h3><p>先来看看最新确立的 <code>JavaScript</code> 语言标准 <code>ES2015</code> 原生支持的类继承语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现子类对父类的继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">        <span class="comment">// ES2015 在原生类继承上</span></div><div class="line">        <span class="comment">// 不能在 super 执行前,在 this 上添加属性或者方法</span></div><div class="line">        <span class="comment">// 原因在于 ES2015 的子类中的 this 由它将要继承的父类来提供</span></div><div class="line">        <span class="comment">// 在 super 调用前, 子类中没有 this 对象, 强行添加属性会报语法错</span></div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    move() &#123;</div><div class="line">        <span class="keyword">this</span>.x += <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.y += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// new一个 Child 类的实例对象</span></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child;</div></pre></td></tr></table></figure>
<p>而在 <code>ES5</code> 中, 我们可以通过用原型继承来模拟类型继承, 这其实就是组合继承模式, 也叫伪经典继承. 背后的思路是</p>
<blockquote>
<ol>
<li>使用原型链实现对父构造函数原型对象上方法和属性的继承</li>
<li>使用借用构造函数的方式实现对父构造函数实例属性的继承.</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parents</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 为父构造函数添加原型方法</span></div><div class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">x, y, color</span>) </span>&#123;</div><div class="line">    <span class="comment">// 在实例化对象时先创建好了 this 对象,然后再调用 Parent 函数</span></div><div class="line">    <span class="comment">// 传入 this ,让 this 得到 Parent 里的实例属性或者实例方法</span></div><div class="line">    Parent.call(<span class="keyword">this</span>, x, y);</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 此处关键点的实现上有另外一种,区别在于是否会取代 Parent.prototype</span></div><div class="line"><span class="comment">// Child.prtotype.__proto__ = Parent.prototype;</span></div><div class="line"></div><div class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</div><div class="line"></div><div class="line"><span class="comment">// 手动恢复 constructor</span></div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="comment">// 此时完成了原型继承</span></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">45</span>, <span class="string">'green'</span>);</div></pre></td></tr></table></figure>
<h3 id="TypeScript-的实现"><a href="#TypeScript-的实现" class="headerlink" title="TypeScript 的实现"></a>TypeScript 的实现</h3><p>现在 <code>JavaScript</code> 语言有各种更高版本的实现, 我们可以通过 <code>babel</code> 使用 <code>ES2015</code> 甚至是 <code>ES2017</code> 的语言特性, 而不用考虑浏览器的兼容问题. 此外, 在微软的 <code>C#</code> 之父 <code>Anders Hejlsberg</code> 领导了 <code>TypeScript</code> 的实现, 这门语言是 ES2015 标准的超集, 并在此之上添加了类型系统, 泛型等语言特性, 通过使用 <code>TypeScript</code> , 我们可以在编辑器中使用类型推导, 这在开发上为我们提供了便利, 尤其是对那些有强类型语言背景的人来说.</p>
<p>在 TypeScript 中的类继承语法如下.</p></div><a href="/2016/06/21/ES2015 Class/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/13/photoshop-e9-a2-9c-e8-89-b2-e6-a8-a1-e5-bc-8f-e5-85-a5-e9-97-a8/" class="post-title-link">PhotoShop颜色模式入门</a></h2><div class="post-info">Apr 13, 2016</div><div class="post-content"><p>我们在开启ps软件之前不妨思考一下这样一个问题，我们的照片或图片，在不同载体上的呈现是否有所不同呢？比如在我们自己的显示器上或者将其在纸张上打印出来，我们是不是观察到了两者在观感上的差异，接下来我将对这些差异背后的原理做一个总结和解释，以供参考。</p>
<h2 id="光与感知的关系"><a href="#光与感知的关系" class="headerlink" title="光与感知的关系"></a>光与感知的关系</h2><p>在我们日常的生活中其实有两种非常不一样的颜色模式，可能大多数人并未去仔细区分二者的异同。具体来说，光的表现形式和日常颜色的表现形式是有所不同的，但二者却又互为一体。听起来是否像个哲学式的命题？可能有点。但无论如何，这本质上其实还是是光在不同情况下的表现，在进入人眼途径上一种是直接进入人眼，另一种则经过反射进入人眼，那么我们接下来具体看看这两种模式的原理和具体表现。</p>
<h2 id="1，加色模式"><a href="#1，加色模式" class="headerlink" title="1，加色模式"></a>1，加色模式</h2><p>我们先来着眼于光在人眼的感知形式，首先我们要确定的一点是，光的颜色模式是“加色模式”。什么是加色模式？光的三原色是“红<code>（Red）</code>，绿<code>（Green）</code>，蓝<code>（Blue）</code>”，在数值上每种原色用<code>0-255</code>这个区间共<code>256</code>个数值来表示该原色物理层面上显像像素点的亮度，例如：<code>RGB（113,159,66</code>）表示的就是，红色（R）亮度是113个单位，绿色159个单位，而蓝色66个单位，这三种亮度不同的三原色光混合就得到了一块其他色相的光，在我的电脑上这是一块深绿色。</p>
<p><img src="/images/2016041317.png" alt="20160413171021"></p>
<p>那么加色模式的具体表现就是，在我们将三种不同的光都设置最大值<code>RGB(255,255,255)</code>时，我们会得到一块白色，而最小值<code>RGB（0,0,0）</code>则会得到一块黑色，这种随着色的增加，最终会得到包罗三原色的白色（可分可逆为三原色）的模式，我们将其称作加色模式。</p>
<p><img src="/images/2000pxBayer.png" alt="Bayer_pattern_on_sensor.svg"></p>
<p>或许这有一点反直觉，因为我们在小时候的美术课上将不同颜色颜料混合起来总会得到一块乌黑的颜色，那为什么我们将加色模式的颜色混合起来却得到白色呢？接下来的“减色模式”可能是这个问题的答案。<br></div><a href="/2016/04/13/photoshop-e9-a2-9c-e8-89-b2-e6-a8-a1-e5-bc-8f-e5-85-a5-e9-97-a8/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/14/关于querySelectorAll 的一些区分/" class="post-title-link">对querySelectorAll 的一些区分</a></h2><div class="post-info">Feb 14, 2016</div><div class="post-content"><p>在一年多以前我在入门前端的时候学习到 <code>querySelectorAll</code> 时有一个疑问, 这么强大的 js 选择器方法且在浏览器端支持到 IE8+, 为什么在网上很难看到其他人在使用, 经过对 <code>JavaScript DOM</code>特性的深入了解和查阅一些资料, 发现自己对 DOM 的一些概念没有加以深刻的区分, 今天就来对这个方法做一个总结.</p>
<h2 id="类型上的区分"><a href="#类型上的区分" class="headerlink" title="类型上的区分"></a>类型上的区分</h2><p>说道 <code>querySelector()</code>和 <code>querySelectorAll()</code> 这两个方法, 首先要明确的是它是 W3C 组织对 <code>DOM API</code> 的专有扩展, 名叫 <code>Selectors API Level 1</code>, 与 <code>getElementsBy*</code> 系列分属不同的 API 集合, 扩展方法得以成为标准得益于 JS 社区面对频繁繁琐的 DOM 操作实现的各种选择器轮子, 最出名的当属从 <code>jQuery</code> 中独立出的 <code>Sizzle</code>.</p>
<p>随着移动端在互联网终端份额中独占鳌头, 移动前端开发者迫切需要一个轻量级不需要考虑 PC Web 端那么多历史遗留问题的类<code>jQuery</code>库, <code>Zepto</code>应运而生, 就其内部选择器的实现上比 jQuery 的选择器模块小很多, 这是其轻量的重要原因之一, 下面的代码就是 <code>Zepto 0.8</code> 版本的选择器模块.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// $$ 核心选择器函数</span></div><div class="line">$.qsa = $$ = <span class="function"><span class="keyword">function</span>(<span class="params">element, selector</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> found;</div><div class="line">    <span class="comment">// 匹配id选择器</span></div><div class="line">    <span class="keyword">return</span> (element === <span class="built_in">document</span> &amp;&amp; idSelectorRE.test(selector)) ?</div><div class="line">        ((found = element.getElementById(<span class="built_in">RegExp</span>.$<span class="number">1</span>)) ? [found] : emptyArray) :</div><div class="line">        slice.call(</div><div class="line">            <span class="comment">// 匹配 .className 类选择器</span></div><div class="line">            classSelectorRE.test(selector) ? element.getElementsByClassName(<span class="built_in">RegExp</span>.$<span class="number">1</span>) :</div><div class="line">            <span class="comment">// 匹配 div 标签选择器</span></div><div class="line">            tagSelectorRE.test(selector) ? element.getElementsByTagName(selector) :</div><div class="line">            <span class="comment">// 都不匹配就 传入到 querySelectorAll() 方法来选择 dom 元素</span></div><div class="line">            element.querySelectorAll(selector)</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Zepto</code> 在 <code>0.8</code> 版本之后选择器架构上做了一些升级, 但大概的设计原则没有变, 就是能用 <code>getElementsBy*</code> 系列的就尽量不使用 <code>querySelectorAll</code><br></div><a href="/2016/02/14/关于querySelectorAll 的一些区分/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/01/14/hello-world/" class="post-title-link">Hello World</a></h2><div class="post-info">Jan 14, 2016</div><div class="post-content"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure></div><a href="/2016/01/14/hello-world/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"></div><div class="copyright"><p>© 2015 - 2016 <a href="http://www.pedclub.com">ped</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>